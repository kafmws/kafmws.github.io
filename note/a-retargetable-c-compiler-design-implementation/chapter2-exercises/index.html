<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><title>Chapter2 Exercises | kafm's blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link href="/fonts/Inter-Regular.woff2?v=4.0" rel=preload type=font/woff2 as=font crossorigin><link href="/fonts/Inter-Italic.woff2?v=4.0" rel=preload type=font/woff2 as=font crossorigin><link href="/fonts/Inter-Bold.woff2?v=4.0" rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/iosevka-regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/iosevka-extended.woff2 rel=preload type=font/woff2 as=font crossorigin><link rel=stylesheet type=text/css href=/style.min.05aa2b4e17474bd3f2a8db5a905a1bd3edbab9fdea9c510d0f44948117b88e21.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/blog.html>Home</a></li><li><a tabindex=-1 class=menu-link href=/categories/>Categories</a></li><li><a tabindex=-1 class=menu-link href=/tags/>Tags</a></li><li><a tabindex=-1 class=menu-link href=/bookmarks/>Bookmarks</a></li><li><a tabindex=-1 class=menu-link href=/index.html>Me</a></li></ul></nav><div id=single-header><h1>Chapter2 Exercises</h1><div id=single-meta><span class=datesub>Mar 12, 2021</span>
<span id=tags>&nbsp;│&nbsp;
<span><a href=http://kafm.eu.org/tags/compiler/># Compiler</a>
</span>&nbsp;</span></div></div><aside class="hidden lg:block toc" id=tableOfContentContainer><nav id=TableOfContents><ul><li><ul><li></li></ul></li></ul></nav></aside><main><ul><li><a href=#chapter2-exercises>Chapter2 Exercises</a>
- <a href=#21>2.1</a>
- <a href=#22>2.2</a>
- <a href=#23>2.3</a>
- <a href=#24>2.4</a>
- <a href=#25>2.5</a>
- <a href=#26>2.6</a>
- <a href=#27>2.7</a>
- <a href=#28>2.8</a>
- <a href=#29>2.9</a>
- <a href=#210>2.10</a>
- <a href=#211>2.11</a>
- <a href=#212>2.12</a>
- <a href=#213>2.13</a>
- <a href=#214>2.14</a>
- <a href=#215>2.15</a></li></ul><h1 id=chapter2-exercises>Chapter2 Exercises</h1><h5 id=21>2.1</h5><blockquote><p>使用<code>C</code>的库函数<code>malloc</code>和<code>free</code>修改<code>allocate</code>和<code>deallocate</code>。</p></blockquote><h5 id=22>2.2</h5><blockquote><p>在<code>lcc</code>中，如果要在多个算法和设计中进行选择，唯一客观的途径就是实现这些算法和方法，并对其效果进行评测。将<code>lcc</code>用于编译其自身的源代码是一种很好的测量标准。请对基于分配区的算法和练习<code>2.1</code>所实现的采用<code>malloc</code>和<code>free</code>的方法的性能进行评测。</p></blockquote><h5 id=23>2.3</h5><blockquote><p>重新定义<code>NEW</code>，使其尽可能在分配区内部进行分配，即只有当分配区的空间不够时才调用<code>allocate</code>。测试其效果。为了实现内部分配方法，必须输出分配区的数据结构。</p></blockquote><h5 id=24>2.4</h5><blockquote><p>当<code>allocate</code>建立了一个新块时，提供了一个好时机，如果这个新块和该分配区中前一个块相邻，就可以将二者连成一个更大的块，实现并测试这种方法的改进效果。</p></blockquote><h5 id=25>2.5</h5><blockquote><p>当<code>allocate</code>从<code>freeblocks</code>中取走一个块时，有可能这个块太小。对分配程序进行插桩，看看这种情况是否经常发生,这个问题值得修改吗?</p></blockquote><h5 id=26>2.6</h5><blockquote><p>说明<code>deallocate</code>在分配区列表只有长度为0的块时也能正确工作。</p></blockquote><h5 id=27>2.7</h5><blockquote><p><code>deallocate</code>从不真正释放块，如通过调用<code>free</code>。在某些输入情况下，<code>lcc</code>的分配区会临时膨胀，而已分配的块不会再被利用。修改<code>deallocate</code>以释放块，而不是将其加入<code>freeblocks</code>中。这种改变能使<code>lcc</code>运行得更快吗?</p></blockquote><h5 id=28>2.8</h5><blockquote><p>为<code>lcc</code>实现一个保守的垃圾收集程序，或者利用一个已有的垃圾收集程序。<code>Boehm and Weiser (1988)</code>介绍的收集程序是公开的。大多数这类分配程序在进行分配时会调用收集程序或部分收集程序，因此你可以去掉<code>deallocate</code>，或者将其定义为空的宏，并修改<code>allocate</code>以调用相应的分配函数。</p></blockquote><h5 id=29>2.9</h5><blockquote><p>通过<code>stringn</code>在字符串表中建立的字符串不会被删除。这种特点会带来问题吗?调用<code>stringn</code>看字符串表的大小分布情况。如果表格太大，如何修改字符串接口，使其允许删除字符串?</p></blockquote><h5 id=210>2.10</h5><blockquote><p><code>stringd</code>将其参数格式化成字符串，存入长度为<code>25</code>的字符数组<code>str</code>中。请解释为什么<code>25</code>对于当前<code>lcc</code>运行并产生代码的计算机已经足够了。</p></blockquote><h5 id=211>2.11</h5><blockquote><p>许多传给<code>stringd</code>的整数很小，比如在<code>-100</code>到<code>100</code>之间。这些整数对应的字符串在编译时就可以进行预分配，<code>stringd</code>和<code>stringn</code>只要返回指向这些字符串的指针而无须再分配。实现这种优化措施，能使<code>lcc</code>运行加快吗？</p></blockquote><h5 id=212>2.12</h5><blockquote><p><code>stringn</code>用较大的内存块来存放字符串中的字符，而不会为每个字符串都调用<code>allocate</code>。修改<code>stringn</code>使得它为每个字符串调用一次<code>allocate</code>。比较这两种方法在时间和空间上的差别，并解释这些差别。</p></blockquote><h5 id=213>2.13</h5><blockquote><p><code>stringn</code>的哈希表的大小是<code>2</code>的幂，这种方法经常遭到反对。尝试将其大小设成某个素数并衡量效果。请设计一种更好的哈希函数并考察其结果。</p></blockquote><h5 id=214>2.14</h5><blockquote><p><code>stringn</code>比较字符串采取的是内联代码，而不是调用<code>memcmp</code>函数。请用调用<code>memcmp</code>代替内联代码。并考察结果。为什么我们要采取内联方法?</p></blockquote><h5 id=215>2.15</h5><blockquote><p><code>lcc</code>大量使用了指针循环列表, <code>list.c</code>模块的实现可视为使用分配宏<code>(allocation macro)</code>的例子，<code>list.c</code>输出了列表元素的类型和3个列表操作函数:</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>list</span> <span class=o>*</span><span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>list</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=n>List</span> <span class=n>append</span> <span class=nf>ARGS</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=n>x</span><span class=p>,</span> <span class=n>List</span> <span class=n>list</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=n>length</span> <span class=nf>ARGS</span><span class=p>((</span><span class=n>List</span> <span class=n>list</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>void</span> <span class=o>*</span><span class=n>ltov</span> <span class=nf>ARGS</span><span class=p>((</span><span class=n>List</span> <span class=o>*</span><span class=n>list</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>a</span><span class=p>));</span>
</span></span></code></pre></div><blockquote><p><code>List</code>保存了<code>0</code>或多个元素，每个元素存放在<code>list</code>结构的<code>x</code>域中。<code>List</code>指向列表中最后一个<code>list</code>结构,空的<code>List</code>定义为空列表。<code>append</code>函数把包含<code>x</code>的节点加入<code>list</code>列表的末尾并返回<code>list</code>。<code>length</code>函数返回列表中元素的数目。<code>ltov</code>函数把 <code>list</code>中的<code>n</code>个元素复制到<code>a</code>所指的分配区中以空元素结尾的指针数组，释放列表结构并返回该数组。数组中有<code>n+1</code>个元素，包含一个空元素。请实现这种列表模块。</p></blockquote><p>==解答==：
函数实现如下，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>static</span> <span class=n>List</span> <span class=n>freenodes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>List</span> <span class=nf>append</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>x</span><span class=p>,</span> <span class=n>List</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>new</span> <span class=o>=</span> <span class=n>freenodes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>freenodes</span> <span class=o>=</span> <span class=n>freenodes</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nf>NEW</span><span class=p>(</span><span class=n>new</span><span class=p>,</span> <span class=n>PERM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>new</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span> <span class=n>head</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>head</span> <span class=o>=</span> <span class=n>list</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span><span class=o>-&gt;</span><span class=n>link</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>new</span><span class=o>-&gt;</span><span class=n>link</span> <span class=o>=</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>length</span><span class=p>(</span><span class=n>List</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>list</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span> <span class=n>p</span> <span class=o>=</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>((</span><span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>p</span> <span class=o>!=</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>len</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>ltov</span><span class=p>(</span><span class=n>List</span> <span class=o>*</span><span class=n>list</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// list to vector
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=cm>/*没有边遍历边释放结点边申请单个元素空间复制元素是因为，
</span></span></span><span class=line><span class=cl><span class=cm>  没法保证连续allocate得到的多个空间是连续的，如字节对齐*/</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=o>*</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>List</span> <span class=n>pre</span><span class=p>,</span> <span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>list</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>;</span> <span class=c1>// p-&gt;head of list
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=nf>length</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>**</span><span class=n>arr</span> <span class=o>=</span> <span class=nf>newarray</span><span class=p>(</span><span class=n>len</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>),</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span><span class=p>[</span><span class=n>cnt</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pre</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pre</span><span class=o>-&gt;</span><span class=n>link</span> <span class=o>=</span> <span class=n>freenodes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>freenodes</span> <span class=o>=</span> <span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>pre</span> <span class=o>!=</span> <span class=o>*</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>arr</span><span class=p>[</span><span class=n>cnt</span><span class=p>]</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>list</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>测试程序如下，</p><details><summary>点击展开代码</summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;test.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;c.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>block</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>limit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>avail</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=n>align</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>long</span> <span class=n>l</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>f</span><span class=p>)(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=n>header</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>block</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>union</span> <span class=n>align</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>block</span> <span class=n>first</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{{</span><span class=nb>NULL</span><span class=p>},</span> <span class=p>{</span><span class=nb>NULL</span><span class=p>},</span> <span class=p>{</span><span class=nb>NULL</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>                    <span class=o>*</span><span class=n>arena</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=o>&amp;</span><span class=n>first</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>first</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>first</span><span class=p>[</span><span class=mi>2</span><span class=p>]};</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>block</span> <span class=o>*</span><span class=n>freeblocks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>allocate</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>n</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>block</span> <span class=o>*</span><span class=n>ap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>a</span> <span class=o>&lt;</span> <span class=nf>NELEMS</span><span class=p>(</span><span class=n>arena</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>ap</span> <span class=o>=</span> <span class=n>arena</span><span class=p>[</span><span class=n>a</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>n</span> <span class=o>=</span> <span class=nf>roundup</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>union</span> <span class=n>align</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=n>ap</span><span class=o>-&gt;</span><span class=n>limit</span> <span class=o>-</span> <span class=n>ap</span><span class=o>-&gt;</span><span class=n>avail</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>ap</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>freeblocks</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>freeblocks</span> <span class=o>=</span> <span class=n>freeblocks</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>ap</span> <span class=o>=</span> <span class=n>ap</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>unsigned</span> <span class=n>m</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=k>sizeof</span><span class=p>(</span><span class=k>union</span> <span class=n>header</span><span class=p>)</span> <span class=o>+</span> <span class=n>n</span> <span class=o>+</span> <span class=nf>roundup</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=mi>1024</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>union</span> <span class=n>align</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=n>ap</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>ap</span> <span class=o>=</span> <span class=n>ap</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>ap</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;insufficient memory</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>ap</span><span class=o>-&gt;</span><span class=n>limit</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>ap</span> <span class=o>+</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>ap</span><span class=o>-&gt;</span><span class=n>avail</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)((</span><span class=k>union</span> <span class=n>header</span> <span class=o>*</span><span class=p>)</span><span class=n>ap</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ap</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>arena</span><span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=o>=</span> <span class=n>ap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>ap</span><span class=o>-&gt;</span><span class=n>avail</span> <span class=o>+=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ap</span><span class=o>-&gt;</span><span class=n>avail</span> <span class=o>-</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>newarray</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>m</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>n</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>allocate</span><span class=p>(</span><span class=n>m</span> <span class=o>*</span> <span class=n>n</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>deallocate</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>a</span> <span class=o>&lt;</span> <span class=nf>NELEMS</span><span class=p>(</span><span class=n>arena</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>arena</span><span class=p>[</span><span class=n>a</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>freeblocks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>freeblocks</span> <span class=o>=</span> <span class=n>first</span><span class=p>[</span><span class=n>a</span><span class=p>].</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>first</span><span class=p>[</span><span class=n>a</span><span class=p>].</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>arena</span><span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>first</span><span class=p>[</span><span class=n>a</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define PERM 0
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>list</span> <span class=o>*</span><span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>list</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=n>List</span> <span class=nf>append</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>x</span><span class=p>,</span> <span class=n>List</span> <span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=nf>length</span><span class=p>(</span><span class=n>List</span> <span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>void</span> <span class=o>*</span><span class=nf>lotv</span><span class=p>(</span><span class=n>List</span> <span class=o>*</span><span class=n>list</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>List</span> <span class=n>freenodes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>List</span> <span class=nf>append</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>x</span><span class=p>,</span> <span class=n>List</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>new</span> <span class=o>=</span> <span class=n>freenodes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>freenodes</span> <span class=o>=</span> <span class=n>freenodes</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nf>NEW</span><span class=p>(</span><span class=n>new</span><span class=p>,</span> <span class=n>PERM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>new</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span> <span class=n>head</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>head</span> <span class=o>=</span> <span class=n>list</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span><span class=o>-&gt;</span><span class=n>link</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>new</span><span class=o>-&gt;</span><span class=n>link</span> <span class=o>=</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>length</span><span class=p>(</span><span class=n>List</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>list</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span> <span class=n>p</span> <span class=o>=</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>((</span><span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>p</span> <span class=o>!=</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>len</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>ltov</span><span class=p>(</span><span class=n>List</span> <span class=o>*</span><span class=n>list</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// list to vector
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=cm>/*没有边遍历边释放结点边申请单个元素空间复制元素是因为，
</span></span></span><span class=line><span class=cl><span class=cm>  没法保证连续allocate得到的多个空间是连续的，如字节对齐*/</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=o>*</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>List</span> <span class=n>pre</span><span class=p>,</span> <span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>list</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>;</span> <span class=c1>// p-&gt;head of list
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=nf>length</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>**</span><span class=n>arr</span> <span class=o>=</span> <span class=nf>newarray</span><span class=p>(</span><span class=n>len</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>),</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span><span class=p>[</span><span class=n>cnt</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pre</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pre</span><span class=o>-&gt;</span><span class=n>link</span> <span class=o>=</span> <span class=n>freenodes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>freenodes</span> <span class=o>=</span> <span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>pre</span> <span class=o>!=</span> <span class=o>*</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>arr</span><span class=p>[</span><span class=n>cnt</span><span class=p>]</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>list</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>TESTNUM</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>List</span> <span class=n>list</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>test_num</span><span class=p>[</span><span class=mi>100</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>},</span> <span class=o>*</span><span class=n>num_addr</span><span class=p>[</span><span class=mi>100</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>},</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>TESTNUM</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>test_num</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>num_addr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>test_num</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>EXPECT_EQ_INT</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=nf>length</span><span class=p>(</span><span class=n>list</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span> <span class=o>=</span> <span class=nf>append</span><span class=p>(</span><span class=o>&amp;</span><span class=n>test_num</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=o>**</span><span class=n>num</span> <span class=o>=</span> <span class=nf>ltov</span><span class=p>(</span><span class=o>&amp;</span><span class=n>list</span><span class=p>,</span> <span class=n>PERM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>EXPECT_TRUE</span><span class=p>(</span><span class=n>list</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>EXPECT_TRUE</span><span class=p>(</span><span class=nf>length</span><span class=p>(</span><span class=n>freenodes</span><span class=p>)</span> <span class=o>==</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>EXPECT_EQ_ARRAY</span><span class=p>((</span><span class=kt>int</span> <span class=o>**</span><span class=p>)</span><span class=n>num_addr</span><span class=p>,</span> <span class=n>num</span><span class=p>,</span> <span class=n>TESTNUM</span><span class=p>,</span> <span class=s>&#34;%p&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>TESTNUM</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span> <span class=o>=</span> <span class=nf>append</span><span class=p>(</span><span class=o>&amp;</span><span class=n>test_num</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>EXPECT_TRUE</span><span class=p>(</span><span class=n>freenodes</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>MAIN_RET</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></details
&emsp;></main><br><hr><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.js crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/contrib/auto-render.min.js crossorigin=anonymous referrerpolicy=no-referrer onload=renderMathInElement(document.body)></script><br><div><img class=rose-icon src=/images/rose.svg></div><footer><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href="/tags";else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));window.addEventListener("scroll",function(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}})}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script>window.store={"http://kafm.eu.org/categories/a-retargetable-c-compiler-design-implementation/":{title:"A Retargetable C Compiler Design \u0026 Implementation",tags:[],content:"",url:"http://kafm.eu.org/categories/a-retargetable-c-compiler-design-implementation/"},"http://kafm.eu.org/categories/":{title:"Categories",tags:[],content:"",url:"http://kafm.eu.org/categories/"},"http://kafm.eu.org/note/a-retargetable-c-compiler-design-implementation/chapter3-symbol-management/":{title:"Chapter2 Memory Management",tags:["Compiler"],content:`Symbol Management 符号表概念 符号表是编译器保存信息的中心库，编译器的各部分通过符号表进行交互，并访问符号表中的数据——符号。 例如， 词法分析器把标识符加入标识符表中； 由分析器添加这些标识符的类型信息； 代码生成器则为符号表中各个表项添加与目标相关的信息，如局部变量和参数的寄存器分配信息；
符号表把各种名字映射到符号集合。常量、标识符和标号都是名字，不同的名字有不同的属性。 例如，作为局部变量名的标识符包括变量的类型、该变量在其声明所在过程的栈帧中的位置以及存储类型； 而作为结构体成员名的标识符则具有完全不同的属性集，包括成员的类型、所在的结构及其在结构中的位置。
符号管理不仅要处理符号本身，还要遵循ANSI C规定的作用域(scope)或可见性(visibility)规则。 标识符的作用域是指在程序中该标识符可见的部分、有效的部分。 C的作用域可以嵌套，一个标识符的可见范围是从该标识符的声明点开始，直到其声明所在的复合语句或参数列表结束。 在所有符合语句或参数列表以外声明的标识符具有文件作用域，其可见范围从声明点开始直到其所在的源文件结束。 在C语言中，内层声明的标识符X会隐藏外层声明的标识符X，即内层同名标识符的作用域形成了外层同名标识符的“空洞”。 符号管理必须要处理这种情况，维护名字与变量之间正确的映射关系。
在“大多数”语言中，如Pascal，标识符只有一个命名空间，即各种用途的标识符都在一个统一的集合中。 在程序的任何地方，对于给定的名字只有一个标识符可见。 ANSI C按照用途对标识符的命名空间进行分类：语句标号、标记(tag)、成员、一般标识符。 标记表示结构体、共用体和枚举的名字（PS:笔者称类型名，原书称tag，译文称标记或类型标记，特指结构体、共用体和枚举声明时所用的名字）。因此有标号、类型名和一般标识符三个命名空间。 对于每个结构体和共用体，其成员都有独立的命名空间。 在程序的同一位置，给定的名字在每个命名空间中最多只有一个对应的标识符可见。也就是说，程序任意一处可能存在多个同名标识符可见，但它们位于不同命名空间，使用方式也有所区别。
粗略地说，不同的命名空间拥有独立的符号表，每个符号表处理各自符号的作用域。 lcc还使用了独立的符号表来处理无作用域集合(unscoped collection)，如常量。 符号表模块的实现在sym.c中。
符号的表示 lcc中的符号以如下结构表示，
typedef struct symbol *Symbol; struct symbol { char *name; int scope; Coordinate src; Symbol up; List uses; int sclass; //symbol flags unsigned structarg:1; unsigned computed:1; unsigned temporary:1; unsigned generated:1; unsigned defined:1; Type type; float ref; union{ //\u0026lt;labels\u0026gt; //\u0026lt;struct types\u0026gt; //\u0026lt;enum constants\u0026gt; //\u0026lt;enum types\u0026gt; //\u0026lt;constants\u0026gt; //\u0026lt;function symbols\u0026gt; //\u0026lt;globals\u0026gt; //\u0026lt;temporaries\u0026gt; } u; Xsymbol x; //\u0026lt;debugger extension\u0026gt; }; `,url:"http://kafm.eu.org/note/a-retargetable-c-compiler-design-implementation/chapter3-symbol-management/"},"http://kafm.eu.org/tags/compiler/":{title:"Compiler",tags:[],content:"",url:"http://kafm.eu.org/tags/compiler/"},"http://kafm.eu.org/":{title:"kafm\u0027s blog",tags:[],content:"",url:"http://kafm.eu.org/"},"http://kafm.eu.org/note/":{title:"Notes",tags:[],content:"",url:"http://kafm.eu.org/note/"},"http://kafm.eu.org/tags/":{title:"Tags",tags:[],content:"",url:"http://kafm.eu.org/tags/"},"http://kafm.eu.org/note/a-retargetable-c-compiler-design-implementation/chapter2-memory-management/":{title:"Chapter2 Memory Management",tags:["Compiler"],content:`Memory Managementlcc 的内存管理分配区的组成内存分配过程内存分配函数实际分配过程分配区的释放字符串的存储字符串函数字符串存储Programming TipsMemory Management 本章介绍了lcc的内存管理——如何分配与回收内存。 内存分配与字符串函数的实现分别在文件alloc.c和string.c中。
lcc 的内存管理 分配区的组成 lcc使用名为分配区（arena）的结构来动态管理内存，生存期相同的对象在同一个分配区中分配， 释放时以分配区为单位释放。每一个分配区都用一个非负整数作为标识，通过这个标识来管理分配区 内存的分配与释放。
每个分配区都是由一组很大的内存块构成的链表。 2-1图表示了1号分配区的组成方式——一个单向链表。 其中，first[1]是其头节点，arena[1]指向1号分配区当前用于分配内存的内存块，同时也是这个链表的尾指针。 （first[1]、arena[1]均带有下标是因为这样的分配区有多个，它们的头节点和尾指针都用数组来管理）。 每个内存块申请后在头部存放一个块头结构struct block（如first[1]），用于管理本块，同时形成链表。
内存块块头的数据结构定义如下，
struct block{ struct block *next; char *limit; char *avail; }; 不难理解，next指向该分配区的下一个内存块，limit存储该内存块的最大地址，avail指向块中可分配区域的首地址。 即从avail到limit之间的空间都是未分配的。
/-+--------+ +--------+| | next |-------------\u0026gt;| next | -------------\u0026gt;...| +--------+ +--------+struct block -+ | avail |--+ | avail |--+ | +--------+ | +--------+ | | | limit |--+-+ | limit |--+-++-+--------+ | | +--------+ | || | cCCC | | | | | | || | | | | | | | || | used | | | | | | || | | | | | ... | | |memmory allocation -+ | | | | | | | || +--------+\u0026lt;-+ | | | | || | | | | | . || | ... | | | | .| | | | | | .| | | | | |\\-+--------+\u0026lt;---+ +--------+ lcc定义了三个arena，由数组将头结点和尾指针组织起来，
static struct block first[] = { { NULL }, { NULL }, { NULL } }, *arena[] = { \u0026amp;first[0], \u0026amp;first[1], \u0026amp;first[2] }; 使用宏、枚举变量或者常量等可以更容易地区分多个分配区，
#define PERM 0 #define FUNC 1 #define STMT 2 //arena[FUNC];存放函数信息的分配区 内存分配过程 内存分配函数 extern void *allocate(unsigned long n, unsigned a); extern void deallocate(unsigned a); allocate在标识符为a的分配区分配字节数为n的内存，返回该段内存的首地址。 deallocate释放标识符为a的分配区。
lcc中allocate通常以宏的方式使用，
#define NEW(p, a) ((p) = allocate(sizeof(*(p)), (a))) #define NEW0(p, a) memset(NEW((p), (a)), 0, sizeof(*(p))) //PS: memset以第一个参数作为返回值 数组分配函数newarray可以调用allocate简单实现。
void *newarray(unsigned long m, unsigned long n, unsigned a) { return allocate(m*n, a); } 实际分配过程 //用于字节对齐的共用体类型声明 union align { long l; char *p; double d; int (*f)(void); };/*union align包含了代表性的类型， 严格表示了宿主机的最小对齐字节数*/ union header { struct block b; union align a; };//该共用体用于初始化struct block中的avail指针位置 allocate具体实现为，向编号为a的分配区arena[a]申请n个字节的空间，将n字节对齐后，
若当前块剩余空间满足请求，分配内存（返回avail指针的位置，并将avail向后偏移n个字节）； 若当前块剩余空间不满足请求 1.依次从freeblocks表头取下空闲内存块加至当前分配区表尾直到满足请求分配内存或freeblocks为空链转2.； 2.申请新的内存块，初始化块头结构，分配内存。 static struct block *freeblocks;//空闲内存块链，deallocate“释放”的内存块放置在此链表中 void *allocate(unsigned long n, unsigned a) { struct block *ap; assert(a \u0026lt; NELEMS(arena)); assert(n \u0026gt; 0); ap = arena[a]; n = roundup(n, sizeof (union align));//字节对齐 while (n \u0026gt; ap-\u0026gt;limit - ap-\u0026gt;avail) {//当前内存块剩余空间不足 if ((ap-\u0026gt;next = freeblocks) != NULL) {//若空闲内存块链表不为空，则从表首取一个内存块 freeblocks = freeblocks-\u0026gt;next; ap = ap-\u0026gt;next; } else {/*freeblocks为空，申请新的内存块，大小为 对齐的struct block字节数(存放表头结构) + 调用allocate时要求的n个字节 + 10KB字节对齐后的字节数(用于后续分配的内存块大小)*/ unsigned m = sizeof (union header) + n + roundup(10*1024, sizeof (union align)); ap-\u0026gt;next = malloc(m);//将申请的新内存块挂到链表尾部 ap = ap-\u0026gt;next; if (ap == NULL) { error(\u0026#34;insufficient memory\\n\u0026#34;); exit(1); } ap-\u0026gt;limit = (char *)ap + m;//置ap-\u0026gt;limit }//else ap-\u0026gt;avail = (char *)((union header *)ap + 1);//使avail指向表头struct block字节对齐后的位置 ap-\u0026gt;next = NULL; arena[a] = ap;//全局指针移向新的分配区 }//while ap-\u0026gt;avail += n;//移动avail，将[avail + avail + n)的n个字节分配出去 return ap-\u0026gt;avail - n;//返回分配的n个字节的起始位置 } 显然，allocate无法一次性分配超过10KB的内存。
分配区的释放 void deallocate(unsigned a) { assert(a \u0026lt; NELEMS(arena));//#define NELEMS(array) ((int)(sizeof(array)/sizeof(array[0]))) arena[a]-\u0026gt;next = freeblocks;//将arena[a]插入至freeblocks表头 freeblocks = first[a].next;//freeblocks指向arena[a]第一个内存块，至此分配区a的内存块链移入freeblocks表头 first[a].next = NULL;//头节点与内存块链断开 arena[a] = \u0026amp;first[a];//尾指针指向头节点 } 释放后的分配区first[a]如下，
+------------------+| |v |+--------+ || next | |+--------+ +----+----+| avail | |arena[a] |+--------+ +---------+| limit |+--------+first[a] 字符串的存储 lcc中将字符串存储在一个字符串的哈希表中，每个字符串只保留一个副本。 这样可以==通过比较字符串地址来确定字符串是否相等，并且节约了空间==。 （哈希表的原理在此不做过多介绍。）
字符串函数 extern char * string(const char *str);//复制从str开始，以\u0026#39;\\0\u0026#39;即(null)为结束标志的字符串，返回字符串首地址 extern char *stringn(const char *str, int len);//复制从str开始的可包括\u0026#39;\\0\u0026#39;的字符串的前len个字节，返回字符串首地址 extern char *stringd(long n);//将整数n转为字符串并返回首地址 /* 3.x版本的声明为stringd(int n)，ANSI C规定long的长度不小于int， 某些环境下int可能只占2个字节而long基本上不少于4字节，选择long尽量支持更大的范围 */ string、stringd均调用了stringn。
char *string(const char *str) { const char *s; for (s = str; *s; s++) ;//find \u0026#39;\\0\u0026#39; return stringn(str, s - str);//不包括结束标志\u0026#39;\\0\u0026#39; } char *stringd(long n) { char str[25], *s = str + sizeof (str); unsigned long m; if (n == LONG_MIN) m = (unsigned long)LONG_MAX + 1;//m = 0x80000000; else if (n \u0026lt; 0) m = -n; else m = n; //m = abs(n); | m = labs(n); do *--s = m%10 + \u0026#39;0\u0026#39;; while ((m /= 10) != 0);//每次取得最后一位记录后丢弃 if (n \u0026lt; 0) *--s = \u0026#39;-\u0026#39;;//处理符号 return stringn(s, str + sizeof (str) - s);//从缓冲区中复制结果并返回，同样不包括\u0026#39;\\0\u0026#39; } /* 由于ANSI C允许不同的机器对于负数取模有不同的处理方式， 因此先计算绝对值大小（使除符号位外的机器数相同），最后再处理符号。 */ 经测试发现stringd的性能在其使用范围内优于sprintf，前者效率约为后者的3倍。 为什么sprintf这么慢呢 测试代码如下，
点击展开代码#include\u0026lt;time.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; char *stringd(long n, char *dst) { char str[25], *s = str + sizeof (str); unsigned long m; if (n == LONG_MIN) m = (unsigned long)LONG_MAX + 1;//m = 0x80000000; else if (n \u0026lt; 0) m = -n; else m = n; //m = abs(n); | m = labs(n); do *--s = m%10 + \u0026#39;0\u0026#39;; while ((m /= 10) != 0);//每次取得最后一位记录后丢弃 if (n \u0026lt; 0) *--s = \u0026#39;-\u0026#39;;//处理符号 return memcpy(dst, s, str + sizeof (str) - s);//从缓冲区中复制结果并返回，同样不包括\u0026#39;\\0\u0026#39; } char *stringd_sprintf(long n, char *dst) { char str[25]; int len = sprintf(str, \u0026#34;%d\u0026#34;, n); return memcpy(dst, str, len);//从缓冲区中复制结果并返回，同样不包括\u0026#39;\\0\u0026#39; } int main() { clock_t start,end; #define TIME_BEGIN start = clock(); #define TIME_END(tip)	{end = clock();printf(#tip\u0026#34; time=%f\\n\u0026#34;,(double)(end-start)/CLK_TCK);} int i = 0; const int TEST_TIMES = 1000000; char res[25] = {0}; for(i = 0;i\u0026lt;TEST_TIMES;i++){ stringd(i, res); } TIME_BEGIN for(i = 0;i\u0026lt;TEST_TIMES;i++){ stringd(i, res); } TIME_END(stringd); for(i = 0;i\u0026lt;TEST_TIMES;i++){ stringd_sprintf(i, res); } TIME_BEGIN for(i = 0;i\u0026lt;TEST_TIMES;i++){ stringd_sprintf(i, res); } TIME_END(stringd_sprintf); return ({1; 0;}); } \u0026emsp;字符串存储 lcc使用一个字符串哈希表来存储字符串，并保证相同的字符串只保留一个副本。 stringn对字符串的每一个字符进行一个随机数表的映射，对所有字符映射数值进一步处理作为hash值。 将字符进行映射的函数如下,
点击展开代码static int scatter[] = {	/* map characters to random values */ 2078917053, 143302914, 1027100827, 1953210302, 755253631, 2002600785, 1405390230, 45248011, 1099951567, 433832350, 2018585307, 438263339, 813528929, 1703199216, 618906479, 573714703, 766270699, 275680090, 1510320440, 1583583926, 1723401032, 1965443329, 1098183682, 1636505764, 980071615, 1011597961, 643279273, 1315461275, 157584038, 1069844923, 471560540, 89017443, 1213147837, 1498661368, 2042227746, 1968401469, 1353778505, 1300134328, 2013649480, 306246424, 1733966678, 1884751139, 744509763, 400011959, 1440466707, 1363416242, 973726663, 59253759, 1639096332, 336563455, 1642837685, 1215013716, 154523136, 593537720, 704035832, 1134594751, 1605135681, 1347315106, 302572379, 1762719719, 269676381, 774132919, 1851737163, 1482824219, 125310639, 1746481261, 1303742040, 1479089144, 899131941, 1169907872, 1785335569, 485614972, 907175364, 382361684, 885626931, 200158423, 1745777927, 1859353594, 259412182, 1237390611, 48433401, 1902249868, 304920680, 202956538, 348303940, 1008956512, 1337551289, 1953439621, 208787970, 1640123668, 1568675693, 478464352, 266772940, 1272929208, 1961288571, 392083579, 871926821, 1117546963, 1871172724, 1771058762, 139971187, 1509024645, 109190086, 1047146551, 1891386329, 994817018, 1247304975, 1489680608, 706686964, 1506717157, 579587572, 755120366, 1261483377, 884508252, 958076904, 1609787317, 1893464764, 148144545, 1415743291, 2102252735, 1788268214, 836935336, 433233439, 2055041154, 2109864544, 247038362, 299641085, 834307717, 1364585325, 23330161, 457882831, 1504556512, 1532354806, 567072918, 404219416, 1276257488, 1561889936, 1651524391, 618454448, 121093252, 1010757900, 1198042020, 876213618, 124757630, 2082550272, 1834290522, 1734544947, 1828531389, 1982435068, 1002804590, 1783300476, 1623219634, 1839739926, 69050267, 1530777140, 1802120822, 316088629, 1830418225, 488944891, 1680673954, 1853748387, 946827723, 1037746818, 1238619545, 1513900641, 1441966234, 367393385, 928306929, 946006977, 985847834, 1049400181, 1956764878, 36406206, 1925613800, 2081522508, 2118956479, 1612420674, 1668583807, 1800004220, 1447372094, 523904750, 1435821048, 923108080, 216161028, 1504871315, 306401572, 2018281851, 1820959944, 2136819798, 359743094, 1354150250, 1843084537, 1306570817, 244413420, 934220434, 672987810, 1686379655, 1301613820, 1601294739, 484902984, 139978006, 503211273, 294184214, 176384212, 281341425, 228223074, 147857043, 1893762099, 1896806882, 1947861263, 1193650546, 273227984, 1236198663, 2116758626, 489389012, 593586330, 275676551, 360187215, 267062626, 265012701, 719930310, 1621212876, 2108097238, 2026501127, 1865626297, 894834024, 552005290, 1404522304, 48964196, 5816381, 1889425288, 188942202, 509027654, 36125855, 365326415, 790369079, 264348929, 513183458, 536647531, 13672163, 313561074, 1730298077, 286900147, 1549759737, 1699573055, 776289160, 2143346068, 1975249606, 1136476375, 262925046, 92778659, 1856406685, 1884137923, 53392249, 1735424165, 1602280572 }; \u0026emsp;字符串，也即字符串表中的基本单元的存储结构如下，因为有len域， struct string实际上可以存储含有'\\0'或者说null的字符串。
static struct string { char *str; int len; struct string *link; } *buckets[1024]; stringn实现了字符串“生成”（如果需要的话）。函数首先计算传入字符串的hash值，检查该字符串是否已经存在， 若不存在则复制该串加入表中然后返回字符串地址，否则直接返回表中副本地址。
char *stringn(const char *str, int len) { int i; unsigned int h; const char *end; struct string *p; assert(str); for (h = 0, i = len, end = str; i \u0026gt; 0; i--)//计算hash值 h = (h\u0026lt;\u0026lt;1) + scatter[*(unsigned char *)end++]; //将*end作为数组下标，所以使用*(unsigned char *)end避免负值 h \u0026amp;= NELEMS(buckets)-1;//h = h % (NELEMS(buckets));//确定表中位置 for (p = buckets[h]; p; p = p-\u0026gt;link)//遍历对应存储位置上的链表，检查该字符串是否已存在 if (len == p-\u0026gt;len) { const char *s1 = str; char *s2 = p-\u0026gt;str; do { if (s1 == end)//len == p-\u0026gt;len, s1==end时s2也到达末尾 return p-\u0026gt;str;//存在相同串，返回副本 } while (*s1++ == *s2++); } { static char *next, *strlimit;//静态局部变量默认初值为0 if (len + 1 \u0026gt;= strlimit - next) { //第一次使用时以及空间不够时申请新的内存空间，地址范围为[next, strlimit) int n = len + 4*1024;//至少4KB next = allocate(n, PERM);//next始终是当前可用空间的起始字节。 //PERM是可作为下标使用的枚举值，表示生命周期为永久的分配区(permanent) strlimit = next + n;//strlimit指向最后一字节的下一个字节 } NEW(p, PERM);//申请struct string结构体空间 p-\u0026gt;len = len; for (p-\u0026gt;str = next; str \u0026lt; end; )//复制字符串到字符串空间，next后移 *next++ = *str++; *next++ = 0;//补充\u0026#39;\\0\u0026#39; p-\u0026gt;link = buckets[h]; buckets[h] = p;//头插入链表 return p-\u0026gt;str;//返回字符串首地址 } } 不难理解，整个字符串表呈如下的结构：
+---------------------++----+----+----+----+---------------+ +-----------+=--\u0026gt;+------------+ ||s.s |... |... |s.s |struct string +----+------\\ : | cEEE | |+-+--+-+--+-+--+-+--+-------+-------+ | | : | string1 | || | | | | | | : | | |v v v v v | | /-+---\u0026gt;+------------+ |. . . . +---------------+ | | | | | cAAA | |. . . . |struct string +----+=-----+--/ | | string2 | |. . . . +-------+-------+ | \\=---+---\u0026gt;+------------+ |. . . . | | | | | |v | | | | |+---------------+ | | | cCCC | ||struct string +----/ | | string3 | |+-------+-------+ | | | || | | | |v | +------------+ |+------+ | | unused | || NULL | | | ... | |+------+ : +------------+ |+---------------------+arena[PERM]中某个内存块 Programming Tips struct T *p = malloc(sizeof(*p)); //struct T *p = malloc(sizeof(struct T)); 在为指针p分配内存时，以sizeof(*p)而非sizeof(struct T)的形式指明申请的内存字节数。使内存分配不依赖于指针指向的类型，避免p的类型发生变化带来的错误。
sizeof运算符仅仅计算类型，而不会求值，也就是说sizeof的运算数不会产生副作用
sizeof(*(int *)NULL);//equals sizeof(int) PS:sizeof是一个运算符而非函数，这意味着上式可以写成
sizeof *(int *)NULL; 判断和式的大小时，使用减法代替加法
if(ap-\u0026gt;avail + n \u0026gt; ap-\u0026gt;limit){//bug//(ap-\u0026gt;avail + n) may overflow}//substitutionif(ap-\u0026gt;limit - ap-\u0026gt;avail \u0026lt; n){//...} 关于未用宏或常量代替的数值，如struct string{} *bucket[1024]。 在一般认识中，为了更好的可读性或者说表意性，对于此类数值量可用#define STRING_HT_SIZE 1024等代替， 而此处仍然使用数值量进行定义，但是在具体使用时以NELEMS(bucket)代替（如hash位置的具体计算）， 应当是预处理后，NELEMS(bucket)扩展为((int)(sizeof (bucket)/sizeof ((bucket)[0])))在编译期直接计算为1024，从而与宏有类似的效率。
传统的建议是哈希表的大小应该取一个素数，而如果取成2的幂，可以使用掩码（masking）运算代替取模运算，得到更好的效率。显然Java中HashMap的设计者也利用了这一点。
`,url:"http://kafm.eu.org/note/a-retargetable-c-compiler-design-implementation/chapter2-memory-management/"},"http://kafm.eu.org/note/a-retargetable-c-compiler-design-implementation/readme/":{title:"Notes for 《A Retargetable C Compiler Design \u0026 Implementation》",tags:["Compiler"],content:`README 本系列文章是经典书籍《A Retargetable C Compiler: Design And Implication 》（《可变目标C编译器：设计与实现》）一书的读书笔记。摘录书中代码加以解释，并记录自己的一些思考。 笔记中的部分代码与与原书中有出入，因为原书代码为lcc 3.x version并且去除了一些assert语句，而笔者所搜集的lcc代码版本为4.2。来自 GitHub.
`,url:"http://kafm.eu.org/note/a-retargetable-c-compiler-design-implementation/readme/"},"http://kafm.eu.org/note/a-retargetable-c-compiler-design-implementation/chapter1-introduction/":{title:"Chapter1 Introduction",tags:["Compiler"],content:`Introduction 本章讲述了本书的阅读方式，lcc的基本概况、设计理念、lcc的工作过程和lcc项目中使用的一些公共声明，主要包括一些兼容性宏及功能性宏。
与许多Unix编译器一样，lcc使用独立的预处理器并且预处理器作为一个独立的进程执行。
根据目标机器的调用约定来产生代码序列，这样才能利用现有的库。
lcc的前端大概有9000行代码，每种与目标相关的代码生成器有700行代码。还有约1000行与目标无关、由所有代码生成器共享的后端代码。
lcc后端使用代码生成器产生器lburg，该产生器可以根据紧缩规范产生代码生成程序。
经验表明，如果为某些语句生成不同目标的代码的过程几乎相同，那么这些语句的代码生成或许可以以后端无关的方式实现，即完全在前端实现。
#define NULL ((void *)0) 以宏 NULL 代替 0 值，在整数和指针类型长度不一致的情况下避免错误
#define roundup(x, n) ((x+((n)-1))\u0026amp;(~((n)-1))) roundup(x, n)返回不小于x且离x最近的n的倍数，n是2的幂。该宏等价与(x + n-1)%n。
#define NELEMS(a) ((int)(sizeof (a)/sizeof ((a)[0]))) 返回使用sizeof运算符进行计算的数组大小，当然参数a必须是数组名。
EBNF，扩展巴科斯范式，|表示左右两边选其一，[]表示其中内容可选，即可出现可不出现，{}表示其中内容可重复0至若干次。()用来分组。 非终结符用斜体显示，非终结符用等宽字体显示，'('表示终结符( PS:EBNF中[]中的内容选择与否可能使[]前的产生式有着截然不同的含义 如： IF '(' expr ')' THEN statement [ ELSE statement ] 上式中，ELSE分句出现与否不影响前面IF ... THEN ...语句的意义 而在下式 factor: ID [ '(' expr {, expr} ')' ] | '(' expr ')' 中，左边的产生式ID [ '(' expr {, expr} ')' ] 若不取可选部分，可表示一个普通ID，而ID '(' expr {, expr} ')'将表示一个函数调用，ID被限定为一个函数名。
`,url:"http://kafm.eu.org/note/a-retargetable-c-compiler-design-implementation/chapter1-introduction/"},"http://kafm.eu.org/note/a-retargetable-c-compiler-design-implementation/chapter2-exercises/":{title:"Chapter2 Exercises",tags:["Compiler"],content:`Chapter2 Exercises- 2.1- 2.2- 2.3- 2.4- 2.5- 2.6- 2.7- 2.8- 2.9- 2.10- 2.11- 2.12- 2.13- 2.14- 2.15Chapter2 Exercises 2.1 使用C的库函数malloc和free修改allocate和deallocate。
2.2 在lcc中，如果要在多个算法和设计中进行选择，唯一客观的途径就是实现这些算法和方法，并对其效果进行评测。将lcc用于编译其自身的源代码是一种很好的测量标准。请对基于分配区的算法和练习2.1所实现的采用malloc和free的方法的性能进行评测。
2.3 重新定义NEW，使其尽可能在分配区内部进行分配，即只有当分配区的空间不够时才调用allocate。测试其效果。为了实现内部分配方法，必须输出分配区的数据结构。
2.4 当allocate建立了一个新块时，提供了一个好时机，如果这个新块和该分配区中前一个块相邻，就可以将二者连成一个更大的块，实现并测试这种方法的改进效果。
2.5 当allocate从freeblocks中取走一个块时，有可能这个块太小。对分配程序进行插桩，看看这种情况是否经常发生,这个问题值得修改吗?
2.6 说明deallocate在分配区列表只有长度为0的块时也能正确工作。
2.7 deallocate从不真正释放块，如通过调用free。在某些输入情况下，lcc的分配区会临时膨胀，而已分配的块不会再被利用。修改deallocate以释放块，而不是将其加入freeblocks中。这种改变能使lcc运行得更快吗?
2.8 为lcc实现一个保守的垃圾收集程序，或者利用一个已有的垃圾收集程序。Boehm and Weiser (1988)介绍的收集程序是公开的。大多数这类分配程序在进行分配时会调用收集程序或部分收集程序，因此你可以去掉deallocate，或者将其定义为空的宏，并修改allocate以调用相应的分配函数。
2.9 通过stringn在字符串表中建立的字符串不会被删除。这种特点会带来问题吗?调用stringn看字符串表的大小分布情况。如果表格太大，如何修改字符串接口，使其允许删除字符串?
2.10 stringd将其参数格式化成字符串，存入长度为25的字符数组str中。请解释为什么25对于当前lcc运行并产生代码的计算机已经足够了。
2.11 许多传给stringd的整数很小，比如在-100到100之间。这些整数对应的字符串在编译时就可以进行预分配，stringd和stringn只要返回指向这些字符串的指针而无须再分配。实现这种优化措施，能使lcc运行加快吗？
2.12 stringn用较大的内存块来存放字符串中的字符，而不会为每个字符串都调用allocate。修改stringn使得它为每个字符串调用一次allocate。比较这两种方法在时间和空间上的差别，并解释这些差别。
2.13 stringn的哈希表的大小是2的幂，这种方法经常遭到反对。尝试将其大小设成某个素数并衡量效果。请设计一种更好的哈希函数并考察其结果。
2.14 stringn比较字符串采取的是内联代码，而不是调用memcmp函数。请用调用memcmp代替内联代码。并考察结果。为什么我们要采取内联方法?
2.15 lcc大量使用了指针循环列表, list.c模块的实现可视为使用分配宏(allocation macro)的例子，list.c输出了列表元素的类型和3个列表操作函数:
typedef struct list *List; struct list{ void *x; List link; }; extern List append ARGS((void *x, List list)); extern int length ARGS((List list)); extern void *ltov ARGS((List *list, unsigned a)); List保存了0或多个元素，每个元素存放在list结构的x域中。List指向列表中最后一个list结构,空的List定义为空列表。append函数把包含x的节点加入list列表的末尾并返回list。length函数返回列表中元素的数目。ltov函数把 list中的n个元素复制到a所指的分配区中以空元素结尾的指针数组，释放列表结构并返回该数组。数组中有n+1个元素，包含一个空元素。请实现这种列表模块。
==解答==： 函数实现如下，
static List freenodes; List append(void *x, List list) { List new; if (new = freenodes) freenodes = freenodes-\u0026gt;link; else NEW(new, PERM); new-\u0026gt;x = x; List head = new; if (list) { head = list-\u0026gt;link; list-\u0026gt;link = new; } new-\u0026gt;link = head; return new; } int length(List list) { if (list == NULL) return 0; int len = 1; List p = list; while ((p = p-\u0026gt;link) \u0026amp;\u0026amp; p != list) { len++; } return len; } void *ltov(List *list, unsigned a) { // list to vector /*没有边遍历边释放结点边申请单个元素空间复制元素是因为， 没法保证连续allocate得到的多个空间是连续的，如字节对齐*/ assert(list); assert(*list); List pre, p = (*list)-\u0026gt;link; // p-\u0026gt;head of list int len = length(p) + 1; void **arr = newarray(len, sizeof(*arr), a); int cnt = 0; do { arr[cnt++] = p-\u0026gt;x; pre = p; p = p-\u0026gt;link; pre-\u0026gt;link = freenodes; freenodes = pre; } while (pre != *list); arr[cnt] = NULL; *list = NULL; return arr; } 测试程序如下，
点击展开代码#include \u0026#34;test.h\u0026#34; #include \u0026#34;c.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;time.h\u0026gt; struct block { struct block *next; char *limit; char *avail; }; union align { long l; char *p; double d; int (*f)(void); }; union header { struct block b; union align a; }; static struct block first[] = {{NULL}, {NULL}, {NULL}}, *arena[] = {\u0026amp;first[0], \u0026amp;first[1], \u0026amp;first[2]}; static struct block *freeblocks; void *allocate(unsigned long n, unsigned a) { struct block *ap; assert(a \u0026lt; NELEMS(arena)); assert(n \u0026gt; 0); ap = arena[a]; n = roundup(n, sizeof(union align)); while (n \u0026gt; ap-\u0026gt;limit - ap-\u0026gt;avail) { if ((ap-\u0026gt;next = freeblocks) != NULL) { freeblocks = freeblocks-\u0026gt;next; ap = ap-\u0026gt;next; } else { unsigned m = sizeof(union header) + n + roundup(10 * 1024, sizeof(union align)); ap-\u0026gt;next = malloc(m); ap = ap-\u0026gt;next; if (ap == NULL) { perror(\u0026#34;insufficient memory\\n\u0026#34;); exit(1); } ap-\u0026gt;limit = (char *)ap + m; } ap-\u0026gt;avail = (char *)((union header *)ap + 1); ap-\u0026gt;next = NULL; arena[a] = ap; } ap-\u0026gt;avail += n; return ap-\u0026gt;avail - n; } void *newarray(unsigned long m, unsigned long n, unsigned a) { return allocate(m * n, a); } void deallocate(unsigned a) { assert(a \u0026lt; NELEMS(arena)); arena[a]-\u0026gt;next = freeblocks; freeblocks = first[a].next; first[a].next = NULL; arena[a] = \u0026amp;first[a]; } #define PERM 0 typedef struct list *List; struct list { void *x; List link; }; extern List append(void *x, List list); extern int length(List list); extern void *lotv(List *list, unsigned a); static List freenodes; List append(void *x, List list) { List new; if (new = freenodes) freenodes = freenodes-\u0026gt;link; else NEW(new, PERM); new-\u0026gt;x = x; List head = new; if (list) { head = list-\u0026gt;link; list-\u0026gt;link = new; } new-\u0026gt;link = head; return new; } int length(List list) { if (list == NULL) return 0; int len = 1; List p = list; while ((p = p-\u0026gt;link) \u0026amp;\u0026amp; p != list) { len++; } return len; } void *ltov(List *list, unsigned a) { // list to vector /*没有边遍历边释放结点边申请单个元素空间复制元素是因为， 没法保证连续allocate得到的多个空间是连续的，如字节对齐*/ assert(list); assert(*list); List pre, p = (*list)-\u0026gt;link; // p-\u0026gt;head of list int len = length(p) + 1; void **arr = newarray(len, sizeof(*arr), a); int cnt = 0; do { arr[cnt++] = p-\u0026gt;x; pre = p; p = p-\u0026gt;link; pre-\u0026gt;link = freenodes; freenodes = pre; } while (pre != *list); arr[cnt] = NULL; *list = NULL; return arr; } int main() { int TESTNUM = 10; List list = NULL; int test_num[100] = {0}, *num_addr[100] = {0}, i; for (i = 0; i \u0026lt; TESTNUM; i++) { test_num[i] = i; num_addr[i] = \u0026amp;test_num[i]; EXPECT_EQ_INT(i, length(list)); list = append(\u0026amp;test_num[i], list); } int **num = ltov(\u0026amp;list, PERM); EXPECT_TRUE(list == NULL); EXPECT_TRUE(length(freenodes) == 10); EXPECT_EQ_ARRAY((int **)num_addr, num, TESTNUM, \u0026#34;%p\u0026#34;); for (i = 0; i \u0026lt; TESTNUM; i++) { list = append(\u0026amp;test_num[i], list); } EXPECT_TRUE(freenodes == NULL); return MAIN_RET; } `,url:"http://kafm.eu.org/note/a-retargetable-c-compiler-design-implementation/chapter2-exercises/"},"http://kafm.eu.org/blog/":{title:"Blogs",tags:[],content:"",url:"http://kafm.eu.org/blog/"},"http://kafm.eu.org/tags/kafm/":{title:"kafm",tags:[],content:"",url:"http://kafm.eu.org/tags/kafm/"},"http://kafm.eu.org/tags/%E7%94%B5%E5%BD%B1/":{title:"电影",tags:[],content:"",url:"http://kafm.eu.org/tags/%E7%94%B5%E5%BD%B1/"},"http://kafm.eu.org/tags/%E8%A7%82%E5%90%8E%E6%84%9F/":{title:"观后感",tags:[],content:"",url:"http://kafm.eu.org/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"},"http://kafm.eu.org/blog/%E9%A9%AC%E5%8E%9F%E4%BD%9C%E4%B8%9A/":{title:"马原作业",tags:["电影","观后感","kafm"],content:`从不止步 我的马原作业。一个奇怪的老师要求写《中国合伙人》和《社交网络》的观后感。
我没有看过《中国合伙人》，也不喜欢看电影。但我很喜欢《社交网络》这部影片，关于这部电影我觉得我有足够的话可以谈，因此这篇观后感是完全关于看《社交网络》的所思所想的。
生活是一盒巧克力，让我们看看放在扎克伯格的盒子里的是哪些东西：一边是平淡生活中“毫无上进心”的女友，一边是自己出人头地的决心与意志；作为生意伙伴的挚友，却与自己理念不符甚至拖后腿；来自上流社会、有平庸想法的哈佛“绅士”对他的种种阻挠；一个具有疯子一样的冒险精神，巴菲特一样的战略眼光，成功道路上志同道合的伙伴，但却有着吸毒、滥交的斑斑劣迹。这些矛盾，扎克伯格都不予理会，他总是望向窗外，或是全神贯注面对屏幕敲击键盘，或仅仅睥睨跟他说话的人，只作简短的回答甚至不作回应。他不开口时仿佛是一个沉默寡言的人，有话说时却又语速极快、滔滔不绝。女友陌路，挚友反目，同伴得意忘形断送前程，可能身败名裂的诉讼摆在面前，扎克伯格的脸上没有任何夸张或扭曲的表情，有的只是无限的沉重，这些沉重不能将他击垮，只能弥漫在他的周围。
他还得敲击键盘，他还有事情要做。
电影开头是男女主人公分手的场景，谈话内容激烈，语速也很快，一下子就把分手的原因、把扎克伯格和女友奥尔布莱特的分歧坦白直观地呈现出来。扎克伯格一心想要干出一番事业，跻身上流社会俱乐部，他像一根绷得很紧的弹簧，像上了发条咯咯咯咯转动不停的机器，以至于奥尔布莱特说和扎克伯格约会就像在跑步机上一样，这样互不理解的两个人，分道扬镳也是迟早的事。不过影片刚开始的时候大部分人并不能完全将注意力集中到影片上，所以这部分稍显冗长。因此我在周五的晚上把开头重新看了一遍。然后这一部分，我感同身受。
初中时代和现在相比，那时的我是一个无忧无虑的小孩，困扰我的事情只有某个女孩到底喜不喜欢我、今天的衣服好不好看和我讨厌的人有没有哪里比我出色。渐渐长大之后，我才觉得大部分人不是那么有趣，世界也并非充满善意。尤其步入大学之后我常常对未来抱有深深的担忧。我害怕我已经泯然众人了，可我学会的第一个成语是不鸣则已，一鸣惊人；我很快就要成为无知乏味群体中的一员了，可我与周遭环境并不相同；我做与不做，时间都会过去；我离家1000公里，没有学问，也无颜见爹娘。我也想做点事情，我也要出人头地。所以我每天像上了发条一样地生活。我曾经有一个关系很好的女同学，是高中同学。关系很好，直到去年11月。我经常跟她讲将来我要怎么怎么样，我会怎么怎么样，讲我要成为的怎样的人我要过的怎样的生活。我一直认为是我每天都在跑步机上向前跑冷落了她所以弄丢了她。但是我不能停下，无论谁离开我，因为我还有事情要做。我的自尊和野心不允许我再停下。（虽然真的常常停下）但是我不能停下，我还有事情要做。
虚度光阴与甘愿平凡的界限似乎没有那么明显，追名逐利与努力上进的界限似乎也没有那么明显。有时会停下来想，驱动我的到底是什么？初心是否早已改变？我仿佛是为了所谓的成功而去努力。计算机科学，当世之显学。它的魅力在于它是众多天才的智慧结晶，在于它惠及社会的方方面面，在于它的从业者可以改变世界。我选择这条道路因为我决心投身于这一事业中去。与此同时我又太渴望成功了，我太渴望发出声音了，我太渴望让世人认可我了。所以我做什么事都在考虑做这件事的意义，可是生活中哪些事又真的有意义？哪些事又能完全没有意义？为了有意义而做的事做了就真的有意义吗？过分在意意义不会使事情失去原本的意义吗？意义又是什么呢？是价值吗？是付出的时间与回报成正比吗？是可以看到的好处还是别的什么呢？偶尔傍晚我坐在教学楼的大楼梯上看人来来往往，有意义吗？扎克伯格是爱着奥尔布莱特的吧，扎克伯格也是雄心勃勃的吧，放下不理解自己的女孩，创造改变世界的东西证明自己，但是人已经失去了，时间也不会回来，这是他想要的意义吗？倘若做出相反的选择，龟缩在世界的角落，将梦想与野心拱手让与温克莱沃斯之流，又是否有愧于心呢？
初中时我有大把的时间看各种各样的书。我躺在地上看天花板，看白色的墙，听歌时用脚在地板上打节拍。学习过得去就行，玩耍有玩伴就好。未来离我那么遥远，我只觉得将来会成为一个与众不同的出色的家伙。其他的我什么也不想，倒也快快乐乐。现在的我无法评判那时的生活。
肖恩用维密创始人的故事讽谏扎克伯格不要停下时，还告诉扎克伯格他高中时喜爱的女孩跟曲棍球队的副队长在一起，因此他想做些改变世界的事情，然后对以前的人说“ I’m CEO, bitch.”。现在他寄予扎克伯格同样的期望。紧接着扎克伯格追问曲棍球女孩故事的下文时，我就知道他不仅当时没有，而且最终也不会放下奥尔布莱特，即使他在庆祝Facebook用户人数突破一百万时印制了“ I’m CEO, bitch.”的名片。影片的最后他还是停留在奥尔布莱特的Facebook主页上，踌躇良久才申请好友验证。
我不知道我有没有放下我的高中同学，但可以肯定的是我常常会想起她。我断然是不会去印“ I’m CEO, bitch.”的名片的。我也不会停下，我还有事情要做。 我会一直奔跑，直到配得上我热爱的事物，也不停下。
changes:
现在喜欢看符合口味的电影 现在是 走走停停 2023/07
`,url:"http://kafm.eu.org/blog/%E9%A9%AC%E5%8E%9F%E4%BD%9C%E4%B8%9A/"},"http://kafm.eu.org/categories/%E6%88%91%E4%BB%AC%E5%9D%90%E7%9A%84%E5%BE%88%E8%BF%91%E6%B2%A1%E6%9C%89%E4%BA%BA%E8%AF%B4%E8%AF%9D%E6%99%9A%E9%A3%8E%E6%9C%89%E4%B8%80%E7%82%B9%E5%87%89/":{title:"我们坐的很近没有人说话晚风有一点凉",tags:[],content:"",url:"http://kafm.eu.org/categories/%E6%88%91%E4%BB%AC%E5%9D%90%E7%9A%84%E5%BE%88%E8%BF%91%E6%B2%A1%E6%9C%89%E4%BA%BA%E8%AF%B4%E8%AF%9D%E6%99%9A%E9%A3%8E%E6%9C%89%E4%B8%80%E7%82%B9%E5%87%89/"}}</script><script defer src=/js/lunr.js></script>
<script defer src=https://cdn.jsdelivr.net/gh/MihaiValentin/lunr-languages/lunr.stemmer.support.js></script>
<script defer src=/js/lunr.zh.js></script>
<script defer src=/js/search.js></script></footer></body></html>